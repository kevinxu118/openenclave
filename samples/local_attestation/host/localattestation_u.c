/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "localattestation_u.h"

#include <openenclave/edger8r/host.h>

OE_EXTERNC_BEGIN

/**** ECALL function wrappers. ****/

oe_result_t get_target_info(
    oe_enclave_t* enclave,
    int* _retval,
    uint8_t** target_info_buffer,
    size_t* target_info_size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    get_target_info_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.target_info_buffer = (uint8_t**)target_info_buffer;
    _args.target_info_size = (size_t*)target_info_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(get_target_info_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(get_target_info_args_t));
    if (target_info_buffer)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t*));
    if (target_info_size)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (get_target_info_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_get_target_info,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (get_target_info_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_OUT_PARAM(target_info_buffer, (size_t)(sizeof(uint8_t*)));
    OE_READ_OUT_PARAM(target_info_size, (size_t)(sizeof(size_t)));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t get_targeted_report_with_pubkey(
    oe_enclave_t* enclave,
    int* _retval,
    uint8_t* target_info_buffer,
    size_t target_info_size,
    uint8_t** pem_key,
    size_t* pem_key_size,
    uint8_t** report,
    size_t* report_size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    get_targeted_report_with_pubkey_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.target_info_buffer = (uint8_t*)target_info_buffer;
    _args.target_info_size = target_info_size;
    _args.pem_key = (uint8_t**)pem_key;
    _args.pem_key_size = (size_t*)pem_key_size;
    _args.report = (uint8_t**)report;
    _args.report_size = (size_t*)report_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(get_targeted_report_with_pubkey_args_t));
    if (target_info_buffer)
        OE_ADD_SIZE(_input_buffer_size, _args.target_info_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(get_targeted_report_with_pubkey_args_t));
    if (pem_key)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t*));
    if (pem_key_size)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    if (report)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t*));
    if (report_size)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (get_targeted_report_with_pubkey_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (target_info_buffer)
        OE_WRITE_IN_PARAM(target_info_buffer, _args.target_info_size, uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_get_targeted_report_with_pubkey,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (get_targeted_report_with_pubkey_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_OUT_PARAM(pem_key, (size_t)(sizeof(uint8_t*)));
    OE_READ_OUT_PARAM(pem_key_size, (size_t)(sizeof(size_t)));
    OE_READ_OUT_PARAM(report, (size_t)(sizeof(uint8_t*)));
    OE_READ_OUT_PARAM(report_size, (size_t)(sizeof(size_t)));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t verify_report_and_set_pubkey(
    oe_enclave_t* enclave,
    int* _retval,
    uint8_t* pem_key,
    size_t key_size,
    uint8_t* report,
    size_t report_size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    verify_report_and_set_pubkey_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.pem_key = (uint8_t*)pem_key;
    _args.key_size = key_size;
    _args.report = (uint8_t*)report;
    _args.report_size = report_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(verify_report_and_set_pubkey_args_t));
    if (pem_key)
        OE_ADD_SIZE(_input_buffer_size, ((size_t)_args.key_size * sizeof(uint8_t)));
    if (report)
        OE_ADD_SIZE(_input_buffer_size, ((size_t)_args.report_size * sizeof(uint8_t)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(verify_report_and_set_pubkey_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (verify_report_and_set_pubkey_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (pem_key)
        OE_WRITE_IN_PARAM(pem_key, ((size_t)_args.key_size * sizeof(uint8_t)), uint8_t*);
    if (report)
        OE_WRITE_IN_PARAM(report, ((size_t)_args.report_size * sizeof(uint8_t)), uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_verify_report_and_set_pubkey,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (verify_report_and_set_pubkey_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t generate_encrypted_message(
    oe_enclave_t* enclave,
    int* _retval,
    uint8_t** data,
    size_t* size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    generate_encrypted_message_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.data = (uint8_t**)data;
    _args.size = (size_t*)size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(generate_encrypted_message_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(generate_encrypted_message_args_t));
    if (data)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t*));
    if (size)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (generate_encrypted_message_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_generate_encrypted_message,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (generate_encrypted_message_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_OUT_PARAM(data, (size_t)(sizeof(uint8_t*)));
    OE_READ_OUT_PARAM(size, (size_t)(sizeof(size_t)));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t process_encrypted_msg(
    oe_enclave_t* enclave,
    int* _retval,
    uint8_t* data,
    size_t size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    process_encrypted_msg_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.data = (uint8_t*)data;
    _args.size = size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(process_encrypted_msg_args_t));
    if (data)
        OE_ADD_SIZE(_input_buffer_size, ((size_t)_args.size * sizeof(uint8_t)));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(process_encrypted_msg_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (process_encrypted_msg_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (data)
        OE_WRITE_IN_PARAM(data, ((size_t)_args.size * sizeof(uint8_t)), uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_process_encrypted_msg,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (process_encrypted_msg_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_verify_report_ecall(
    oe_enclave_t* enclave,
    oe_result_t* _retval,
    const void* report,
    size_t report_size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_verify_report_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.report = (void*)report;
    _args.report_size = report_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_verify_report_ecall_args_t));
    if (report)
        OE_ADD_SIZE(_input_buffer_size, _args.report_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_verify_report_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_verify_report_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (report)
        OE_WRITE_IN_PARAM(report, _args.report_size, void*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_verify_report_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_verify_report_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_log_init_ecall(
    oe_enclave_t* enclave,
    const char* enclave_path,
    uint32_t log_level)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_log_init_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.enclave_path = (char*)enclave_path;
    _args.enclave_path_len = (enclave_path) ? (oe_strlen(enclave_path) + 1) : 0;
    _args.log_level = log_level;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_log_init_ecall_args_t));
    if (enclave_path)
        OE_ADD_SIZE(_input_buffer_size, _args.enclave_path_len * sizeof(char));
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_log_init_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_log_init_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (enclave_path)
        OE_WRITE_IN_PARAM(enclave_path, _args.enclave_path_len * sizeof(char), char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_log_init_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_log_init_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_syscall_stub_ecall(oe_enclave_t* enclave)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_syscall_stub_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_syscall_stub_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_syscall_stub_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_syscall_stub_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_syscall_stub_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_syscall_stub_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_get_sgx_report_ecall(
    oe_enclave_t* enclave,
    oe_result_t* _retval,
    const void* opt_params,
    size_t opt_params_size,
    sgx_report_t* report)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_get_sgx_report_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.opt_params = (void*)opt_params;
    _args.opt_params_size = opt_params_size;
    _args.report = (sgx_report_t*)report;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_get_sgx_report_ecall_args_t));
    if (opt_params)
        OE_ADD_SIZE(_input_buffer_size, _args.opt_params_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_get_sgx_report_ecall_args_t));
    if (report)
        OE_ADD_SIZE(_output_buffer_size, sizeof(sgx_report_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_get_sgx_report_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (opt_params)
        OE_WRITE_IN_PARAM(opt_params, _args.opt_params_size, void*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_get_sgx_report_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_get_sgx_report_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_OUT_PARAM(report, (size_t)(sizeof(sgx_report_t)));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_get_report_v2_ecall(
    oe_enclave_t* enclave,
    oe_result_t* _retval,
    uint32_t flags,
    const void* opt_params,
    size_t opt_params_size,
    uint8_t** report_buffer,
    size_t* report_buffer_size)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_get_report_v2_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.flags = flags;
    _args.opt_params = (void*)opt_params;
    _args.opt_params_size = opt_params_size;
    _args.report_buffer = (uint8_t**)report_buffer;
    _args.report_buffer_size = (size_t*)report_buffer_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_get_report_v2_ecall_args_t));
    if (opt_params)
        OE_ADD_SIZE(_input_buffer_size, _args.opt_params_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_get_report_v2_ecall_args_t));
    if (report_buffer)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t*));
    if (report_buffer_size)
        OE_ADD_SIZE(_output_buffer_size, sizeof(size_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_get_report_v2_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (opt_params)
        OE_WRITE_IN_PARAM(opt_params, _args.opt_params_size, void*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_get_report_v2_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_get_report_v2_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_OUT_PARAM(report_buffer, (size_t)(sizeof(uint8_t*)));
    OE_READ_OUT_PARAM(report_buffer_size, (size_t)(sizeof(size_t)));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_verify_local_report_ecall(
    oe_enclave_t* enclave,
    oe_result_t* _retval,
    const uint8_t* report,
    size_t report_size,
    oe_report_t* parsed_report)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_verify_local_report_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.report = (uint8_t*)report;
    _args.report_size = report_size;
    _args.parsed_report = (oe_report_t*)parsed_report;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_verify_local_report_ecall_args_t));
    if (report)
        OE_ADD_SIZE(_input_buffer_size, _args.report_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_verify_local_report_ecall_args_t));
    if (parsed_report)
        OE_ADD_SIZE(_output_buffer_size, sizeof(oe_report_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_verify_local_report_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (report)
        OE_WRITE_IN_PARAM(report, _args.report_size, uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_verify_local_report_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_verify_local_report_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    OE_READ_OUT_PARAM(parsed_report, (size_t)(sizeof(oe_report_t)));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_sgx_init_context_switchless_ecall(
    oe_enclave_t* enclave,
    oe_result_t* _retval,
    oe_host_worker_context_t* host_worker_contexts,
    uint64_t num_host_workers)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_sgx_init_context_switchless_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.host_worker_contexts = (oe_host_worker_context_t*)host_worker_contexts;
    _args.num_host_workers = num_host_workers;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_sgx_init_context_switchless_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_sgx_init_context_switchless_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_sgx_init_context_switchless_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_sgx_init_context_switchless_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_sgx_init_context_switchless_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

oe_result_t oe_sgx_switchless_enclave_worker_thread_ecall(
    oe_enclave_t* enclave,
    oe_enclave_worker_context_t* context)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshalling struct. */
    oe_sgx_switchless_enclave_worker_thread_ecall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;

    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Deep copy buffer. */
    /* No pointers to save for deep copy. */

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.context = (oe_enclave_worker_context_t*)context;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_sgx_switchless_enclave_worker_thread_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_sgx_switchless_enclave_worker_thread_ecall_args_t));
    /* There were no corresponding parameters. */
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_sgx_switchless_enclave_worker_thread_ecall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             localattestation_fcn_id_oe_sgx_switchless_enclave_worker_thread_ecall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_sgx_switchless_enclave_worker_thread_ecall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    /* No pointers to restore for deep copy. */
    /* There were no out nor in-out parameters. */

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    /* No `_ptrs` to free for deep copy. */

    return _result;
}

/**** OCALL functions. ****/

static void ocall_oe_log_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_log_ocall_args_t* pargs_in = (oe_log_ocall_args_t*)input_buffer;
    oe_log_ocall_args_t* pargs_out = (oe_log_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->message)
        OE_SET_IN_POINTER(message, pargs_in->message_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    oe_log_ocall(
        pargs_in->log_level,
        (const char*)pargs_in->message);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_write_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_write_ocall_args_t* pargs_in = (oe_write_ocall_args_t*)input_buffer;
    oe_write_ocall_args_t* pargs_out = (oe_write_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->str)
        OE_SET_IN_POINTER(str, pargs_in->str_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    oe_write_ocall(
        pargs_in->device,
        (const char*)pargs_in->str,
        pargs_in->maxlen);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_epoll_create1_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_epoll_create1_ocall_args_t* pargs_in = (oe_syscall_epoll_create1_ocall_args_t*)input_buffer;
    oe_syscall_epoll_create1_ocall_args_t* pargs_out = (oe_syscall_epoll_create1_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_epoll_create1_ocall(
        pargs_in->flags);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_epoll_wait_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_epoll_wait_ocall_args_t* pargs_in = (oe_syscall_epoll_wait_ocall_args_t*)input_buffer;
    oe_syscall_epoll_wait_ocall_args_t* pargs_out = (oe_syscall_epoll_wait_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->events)
        OE_SET_OUT_POINTER(events, ((size_t)pargs_in->maxevents * sizeof(struct oe_epoll_event)), struct oe_epoll_event*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_epoll_wait_ocall(
        pargs_in->epfd,
        pargs_in->events,
        pargs_in->maxevents,
        pargs_in->timeout);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_epoll_wake_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_epoll_wake_ocall_args_t* pargs_in = (oe_syscall_epoll_wake_ocall_args_t*)input_buffer;
    oe_syscall_epoll_wake_ocall_args_t* pargs_out = (oe_syscall_epoll_wake_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_epoll_wake_ocall(
    );

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_epoll_ctl_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_epoll_ctl_ocall_args_t* pargs_in = (oe_syscall_epoll_ctl_ocall_args_t*)input_buffer;
    oe_syscall_epoll_ctl_ocall_args_t* pargs_out = (oe_syscall_epoll_ctl_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->event)
        OE_SET_IN_POINTER(event, ((size_t)1 * sizeof(struct oe_epoll_event)), struct oe_epoll_event*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_epoll_ctl_ocall(
        pargs_in->epfd,
        pargs_in->op,
        pargs_in->fd,
        pargs_in->event);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_epoll_close_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_epoll_close_ocall_args_t* pargs_in = (oe_syscall_epoll_close_ocall_args_t*)input_buffer;
    oe_syscall_epoll_close_ocall_args_t* pargs_out = (oe_syscall_epoll_close_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_epoll_close_ocall(
        pargs_in->epfd);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_open_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_open_ocall_args_t* pargs_in = (oe_syscall_open_ocall_args_t*)input_buffer;
    oe_syscall_open_ocall_args_t* pargs_out = (oe_syscall_open_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pathname)
        OE_SET_IN_POINTER(pathname, pargs_in->pathname_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_open_ocall(
        (const char*)pargs_in->pathname,
        pargs_in->flags,
        pargs_in->mode);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_read_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_read_ocall_args_t* pargs_in = (oe_syscall_read_ocall_args_t*)input_buffer;
    oe_syscall_read_ocall_args_t* pargs_out = (oe_syscall_read_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->buf)
        OE_SET_OUT_POINTER(buf, pargs_in->count, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_read_ocall(
        pargs_in->fd,
        pargs_in->buf,
        pargs_in->count);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_write_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_write_ocall_args_t* pargs_in = (oe_syscall_write_ocall_args_t*)input_buffer;
    oe_syscall_write_ocall_args_t* pargs_out = (oe_syscall_write_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->buf)
        OE_SET_IN_POINTER(buf, pargs_in->count, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_write_ocall(
        pargs_in->fd,
        (const void*)pargs_in->buf,
        pargs_in->count);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_readv_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_readv_ocall_args_t* pargs_in = (oe_syscall_readv_ocall_args_t*)input_buffer;
    oe_syscall_readv_ocall_args_t* pargs_out = (oe_syscall_readv_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->iov_buf)
        OE_SET_IN_OUT_POINTER(iov_buf, pargs_in->iov_buf_size, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->iov_buf)
        OE_COPY_AND_SET_IN_OUT_POINTER(iov_buf, pargs_in->iov_buf_size, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_readv_ocall(
        pargs_in->fd,
        pargs_in->iov_buf,
        pargs_in->iovcnt,
        pargs_in->iov_buf_size);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_writev_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_writev_ocall_args_t* pargs_in = (oe_syscall_writev_ocall_args_t*)input_buffer;
    oe_syscall_writev_ocall_args_t* pargs_out = (oe_syscall_writev_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->iov_buf)
        OE_SET_IN_POINTER(iov_buf, pargs_in->iov_buf_size, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_writev_ocall(
        pargs_in->fd,
        (const void*)pargs_in->iov_buf,
        pargs_in->iovcnt,
        pargs_in->iov_buf_size);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_lseek_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_lseek_ocall_args_t* pargs_in = (oe_syscall_lseek_ocall_args_t*)input_buffer;
    oe_syscall_lseek_ocall_args_t* pargs_out = (oe_syscall_lseek_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_lseek_ocall(
        pargs_in->fd,
        pargs_in->offset,
        pargs_in->whence);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_pread_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_pread_ocall_args_t* pargs_in = (oe_syscall_pread_ocall_args_t*)input_buffer;
    oe_syscall_pread_ocall_args_t* pargs_out = (oe_syscall_pread_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->buf)
        OE_SET_OUT_POINTER(buf, pargs_in->count, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_pread_ocall(
        pargs_in->fd,
        pargs_in->buf,
        pargs_in->count,
        pargs_in->offset);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_pwrite_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_pwrite_ocall_args_t* pargs_in = (oe_syscall_pwrite_ocall_args_t*)input_buffer;
    oe_syscall_pwrite_ocall_args_t* pargs_out = (oe_syscall_pwrite_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->buf)
        OE_SET_IN_POINTER(buf, pargs_in->count, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_pwrite_ocall(
        pargs_in->fd,
        (const void*)pargs_in->buf,
        pargs_in->count,
        pargs_in->offset);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_close_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_close_ocall_args_t* pargs_in = (oe_syscall_close_ocall_args_t*)input_buffer;
    oe_syscall_close_ocall_args_t* pargs_out = (oe_syscall_close_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_close_ocall(
        pargs_in->fd);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_dup_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_dup_ocall_args_t* pargs_in = (oe_syscall_dup_ocall_args_t*)input_buffer;
    oe_syscall_dup_ocall_args_t* pargs_out = (oe_syscall_dup_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_dup_ocall(
        pargs_in->oldfd);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_opendir_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_opendir_ocall_args_t* pargs_in = (oe_syscall_opendir_ocall_args_t*)input_buffer;
    oe_syscall_opendir_ocall_args_t* pargs_out = (oe_syscall_opendir_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->name)
        OE_SET_IN_POINTER(name, pargs_in->name_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_opendir_ocall(
        (const char*)pargs_in->name);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_readdir_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_readdir_ocall_args_t* pargs_in = (oe_syscall_readdir_ocall_args_t*)input_buffer;
    oe_syscall_readdir_ocall_args_t* pargs_out = (oe_syscall_readdir_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->entry)
        OE_SET_OUT_POINTER(entry, ((size_t)1 * sizeof(struct oe_dirent)), struct oe_dirent*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_readdir_ocall(
        pargs_in->dirp,
        pargs_in->entry);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_rewinddir_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_rewinddir_ocall_args_t* pargs_in = (oe_syscall_rewinddir_ocall_args_t*)input_buffer;
    oe_syscall_rewinddir_ocall_args_t* pargs_out = (oe_syscall_rewinddir_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    oe_syscall_rewinddir_ocall(
        pargs_in->dirp);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_closedir_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_closedir_ocall_args_t* pargs_in = (oe_syscall_closedir_ocall_args_t*)input_buffer;
    oe_syscall_closedir_ocall_args_t* pargs_out = (oe_syscall_closedir_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_closedir_ocall(
        pargs_in->dirp);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_stat_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_stat_ocall_args_t* pargs_in = (oe_syscall_stat_ocall_args_t*)input_buffer;
    oe_syscall_stat_ocall_args_t* pargs_out = (oe_syscall_stat_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pathname)
        OE_SET_IN_POINTER(pathname, pargs_in->pathname_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->buf)
        OE_SET_OUT_POINTER(buf, ((size_t)1 * sizeof(struct oe_stat_t)), struct oe_stat_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_stat_ocall(
        (const char*)pargs_in->pathname,
        pargs_in->buf);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_access_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_access_ocall_args_t* pargs_in = (oe_syscall_access_ocall_args_t*)input_buffer;
    oe_syscall_access_ocall_args_t* pargs_out = (oe_syscall_access_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pathname)
        OE_SET_IN_POINTER(pathname, pargs_in->pathname_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_access_ocall(
        (const char*)pargs_in->pathname,
        pargs_in->mode);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_link_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_link_ocall_args_t* pargs_in = (oe_syscall_link_ocall_args_t*)input_buffer;
    oe_syscall_link_ocall_args_t* pargs_out = (oe_syscall_link_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->oldpath)
        OE_SET_IN_POINTER(oldpath, pargs_in->oldpath_len * sizeof(char), char*);
    if (pargs_in->newpath)
        OE_SET_IN_POINTER(newpath, pargs_in->newpath_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_link_ocall(
        (const char*)pargs_in->oldpath,
        (const char*)pargs_in->newpath);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_unlink_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_unlink_ocall_args_t* pargs_in = (oe_syscall_unlink_ocall_args_t*)input_buffer;
    oe_syscall_unlink_ocall_args_t* pargs_out = (oe_syscall_unlink_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pathname)
        OE_SET_IN_POINTER(pathname, pargs_in->pathname_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_unlink_ocall(
        (const char*)pargs_in->pathname);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_rename_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_rename_ocall_args_t* pargs_in = (oe_syscall_rename_ocall_args_t*)input_buffer;
    oe_syscall_rename_ocall_args_t* pargs_out = (oe_syscall_rename_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->oldpath)
        OE_SET_IN_POINTER(oldpath, pargs_in->oldpath_len * sizeof(char), char*);
    if (pargs_in->newpath)
        OE_SET_IN_POINTER(newpath, pargs_in->newpath_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_rename_ocall(
        (const char*)pargs_in->oldpath,
        (const char*)pargs_in->newpath);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_truncate_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_truncate_ocall_args_t* pargs_in = (oe_syscall_truncate_ocall_args_t*)input_buffer;
    oe_syscall_truncate_ocall_args_t* pargs_out = (oe_syscall_truncate_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->path)
        OE_SET_IN_POINTER(path, pargs_in->path_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_truncate_ocall(
        (const char*)pargs_in->path,
        pargs_in->length);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_mkdir_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_mkdir_ocall_args_t* pargs_in = (oe_syscall_mkdir_ocall_args_t*)input_buffer;
    oe_syscall_mkdir_ocall_args_t* pargs_out = (oe_syscall_mkdir_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pathname)
        OE_SET_IN_POINTER(pathname, pargs_in->pathname_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_mkdir_ocall(
        (const char*)pargs_in->pathname,
        pargs_in->mode);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_rmdir_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_rmdir_ocall_args_t* pargs_in = (oe_syscall_rmdir_ocall_args_t*)input_buffer;
    oe_syscall_rmdir_ocall_args_t* pargs_out = (oe_syscall_rmdir_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pathname)
        OE_SET_IN_POINTER(pathname, pargs_in->pathname_len * sizeof(char), char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_rmdir_ocall(
        (const char*)pargs_in->pathname);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_fcntl_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_fcntl_ocall_args_t* pargs_in = (oe_syscall_fcntl_ocall_args_t*)input_buffer;
    oe_syscall_fcntl_ocall_args_t* pargs_out = (oe_syscall_fcntl_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->argout)
        OE_SET_IN_OUT_POINTER(argout, pargs_in->argsize, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->argout)
        OE_COPY_AND_SET_IN_OUT_POINTER(argout, pargs_in->argsize, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_fcntl_ocall(
        pargs_in->fd,
        pargs_in->cmd,
        pargs_in->arg,
        pargs_in->argsize,
        pargs_in->argout);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_ioctl_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_ioctl_ocall_args_t* pargs_in = (oe_syscall_ioctl_ocall_args_t*)input_buffer;
    oe_syscall_ioctl_ocall_args_t* pargs_out = (oe_syscall_ioctl_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->argout)
        OE_SET_IN_OUT_POINTER(argout, pargs_in->argsize, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->argout)
        OE_COPY_AND_SET_IN_OUT_POINTER(argout, pargs_in->argsize, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_ioctl_ocall(
        pargs_in->fd,
        pargs_in->request,
        pargs_in->arg,
        pargs_in->argsize,
        pargs_in->argout);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_poll_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_poll_ocall_args_t* pargs_in = (oe_syscall_poll_ocall_args_t*)input_buffer;
    oe_syscall_poll_ocall_args_t* pargs_out = (oe_syscall_poll_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->host_fds)
        OE_SET_IN_OUT_POINTER(host_fds, ((size_t)pargs_in->nfds * sizeof(struct oe_host_pollfd)), struct oe_host_pollfd*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->host_fds)
        OE_COPY_AND_SET_IN_OUT_POINTER(host_fds, ((size_t)pargs_in->nfds * sizeof(struct oe_host_pollfd)), struct oe_host_pollfd*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_poll_ocall(
        pargs_in->host_fds,
        pargs_in->nfds,
        pargs_in->timeout);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_kill_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_kill_ocall_args_t* pargs_in = (oe_syscall_kill_ocall_args_t*)input_buffer;
    oe_syscall_kill_ocall_args_t* pargs_out = (oe_syscall_kill_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_kill_ocall(
        pargs_in->pid,
        pargs_in->signum);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_close_socket_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_close_socket_ocall_args_t* pargs_in = (oe_syscall_close_socket_ocall_args_t*)input_buffer;
    oe_syscall_close_socket_ocall_args_t* pargs_out = (oe_syscall_close_socket_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_close_socket_ocall(
        pargs_in->sockfd);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_socket_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_socket_ocall_args_t* pargs_in = (oe_syscall_socket_ocall_args_t*)input_buffer;
    oe_syscall_socket_ocall_args_t* pargs_out = (oe_syscall_socket_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_socket_ocall(
        pargs_in->domain,
        pargs_in->type,
        pargs_in->protocol);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_shutdown_sockets_device_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_shutdown_sockets_device_ocall_args_t* pargs_in = (oe_syscall_shutdown_sockets_device_ocall_args_t*)input_buffer;
    oe_syscall_shutdown_sockets_device_ocall_args_t* pargs_out = (oe_syscall_shutdown_sockets_device_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_shutdown_sockets_device_ocall(
        pargs_in->sockfd);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_socketpair_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_socketpair_ocall_args_t* pargs_in = (oe_syscall_socketpair_ocall_args_t*)input_buffer;
    oe_syscall_socketpair_ocall_args_t* pargs_out = (oe_syscall_socketpair_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->sv)
        OE_SET_OUT_POINTER(sv, sizeof(oe_host_fd_t[2]), oe_host_fd_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_socketpair_ocall(
        pargs_in->domain,
        pargs_in->type,
        pargs_in->protocol,
        *(oe_host_fd_t(*)[2])pargs_in->sv);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_connect_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_connect_ocall_args_t* pargs_in = (oe_syscall_connect_ocall_args_t*)input_buffer;
    oe_syscall_connect_ocall_args_t* pargs_out = (oe_syscall_connect_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->addr)
        OE_SET_IN_POINTER(addr, pargs_in->addrlen, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_connect_ocall(
        pargs_in->sockfd,
        (const struct oe_sockaddr*)pargs_in->addr,
        pargs_in->addrlen);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_accept_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_accept_ocall_args_t* pargs_in = (oe_syscall_accept_ocall_args_t*)input_buffer;
    oe_syscall_accept_ocall_args_t* pargs_out = (oe_syscall_accept_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->addr)
        OE_SET_IN_OUT_POINTER(addr, pargs_in->addrlen_in, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->addr)
        OE_COPY_AND_SET_IN_OUT_POINTER(addr, pargs_in->addrlen_in, struct oe_sockaddr*);
    if (pargs_in->addrlen_out)
        OE_SET_OUT_POINTER(addrlen_out, ((size_t)1 * sizeof(oe_socklen_t)), oe_socklen_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_accept_ocall(
        pargs_in->sockfd,
        pargs_in->addr,
        pargs_in->addrlen_in,
        pargs_in->addrlen_out);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_bind_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_bind_ocall_args_t* pargs_in = (oe_syscall_bind_ocall_args_t*)input_buffer;
    oe_syscall_bind_ocall_args_t* pargs_out = (oe_syscall_bind_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->addr)
        OE_SET_IN_POINTER(addr, pargs_in->addrlen, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_bind_ocall(
        pargs_in->sockfd,
        (const struct oe_sockaddr*)pargs_in->addr,
        pargs_in->addrlen);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_listen_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_listen_ocall_args_t* pargs_in = (oe_syscall_listen_ocall_args_t*)input_buffer;
    oe_syscall_listen_ocall_args_t* pargs_out = (oe_syscall_listen_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_listen_ocall(
        pargs_in->sockfd,
        pargs_in->backlog);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_recvmsg_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_recvmsg_ocall_args_t* pargs_in = (oe_syscall_recvmsg_ocall_args_t*)input_buffer;
    oe_syscall_recvmsg_ocall_args_t* pargs_out = (oe_syscall_recvmsg_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->msg_iov_buf)
        OE_SET_IN_OUT_POINTER(msg_iov_buf, pargs_in->msg_iov_buf_size, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->msg_name)
        OE_SET_OUT_POINTER(msg_name, pargs_in->msg_namelen, void*);
    if (pargs_in->msg_namelen_out)
        OE_SET_OUT_POINTER(msg_namelen_out, ((size_t)1 * sizeof(oe_socklen_t)), oe_socklen_t*);
    if (pargs_in->msg_iov_buf)
        OE_COPY_AND_SET_IN_OUT_POINTER(msg_iov_buf, pargs_in->msg_iov_buf_size, void*);
    if (pargs_in->msg_control)
        OE_SET_OUT_POINTER(msg_control, pargs_in->msg_controllen, void*);
    if (pargs_in->msg_controllen_out)
        OE_SET_OUT_POINTER(msg_controllen_out, ((size_t)1 * sizeof(size_t)), size_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_recvmsg_ocall(
        pargs_in->sockfd,
        pargs_in->msg_name,
        pargs_in->msg_namelen,
        pargs_in->msg_namelen_out,
        pargs_in->msg_iov_buf,
        pargs_in->msg_iovlen,
        pargs_in->msg_iov_buf_size,
        pargs_in->msg_control,
        pargs_in->msg_controllen,
        pargs_in->msg_controllen_out,
        pargs_in->flags);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_sendmsg_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_sendmsg_ocall_args_t* pargs_in = (oe_syscall_sendmsg_ocall_args_t*)input_buffer;
    oe_syscall_sendmsg_ocall_args_t* pargs_out = (oe_syscall_sendmsg_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->msg_name)
        OE_SET_IN_POINTER(msg_name, pargs_in->msg_namelen, void*);
    if (pargs_in->msg_iov_buf)
        OE_SET_IN_POINTER(msg_iov_buf, pargs_in->msg_iov_buf_size, void*);
    if (pargs_in->msg_control)
        OE_SET_IN_POINTER(msg_control, pargs_in->msg_controllen, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_sendmsg_ocall(
        pargs_in->sockfd,
        (const void*)pargs_in->msg_name,
        pargs_in->msg_namelen,
        pargs_in->msg_iov_buf,
        pargs_in->msg_iovlen,
        pargs_in->msg_iov_buf_size,
        (const void*)pargs_in->msg_control,
        pargs_in->msg_controllen,
        pargs_in->flags);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_recv_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_recv_ocall_args_t* pargs_in = (oe_syscall_recv_ocall_args_t*)input_buffer;
    oe_syscall_recv_ocall_args_t* pargs_out = (oe_syscall_recv_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->buf)
        OE_SET_IN_OUT_POINTER(buf, pargs_in->len, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->buf)
        OE_COPY_AND_SET_IN_OUT_POINTER(buf, pargs_in->len, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_recv_ocall(
        pargs_in->sockfd,
        pargs_in->buf,
        pargs_in->len,
        pargs_in->flags);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_recvfrom_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_recvfrom_ocall_args_t* pargs_in = (oe_syscall_recvfrom_ocall_args_t*)input_buffer;
    oe_syscall_recvfrom_ocall_args_t* pargs_out = (oe_syscall_recvfrom_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->src_addr)
        OE_SET_IN_OUT_POINTER(src_addr, pargs_in->addrlen_in, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->buf)
        OE_SET_OUT_POINTER(buf, pargs_in->len, void*);
    if (pargs_in->src_addr)
        OE_COPY_AND_SET_IN_OUT_POINTER(src_addr, pargs_in->addrlen_in, struct oe_sockaddr*);
    if (pargs_in->addrlen_out)
        OE_SET_OUT_POINTER(addrlen_out, ((size_t)1 * sizeof(oe_socklen_t)), oe_socklen_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_recvfrom_ocall(
        pargs_in->sockfd,
        pargs_in->buf,
        pargs_in->len,
        pargs_in->flags,
        pargs_in->src_addr,
        pargs_in->addrlen_in,
        pargs_in->addrlen_out);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_send_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_send_ocall_args_t* pargs_in = (oe_syscall_send_ocall_args_t*)input_buffer;
    oe_syscall_send_ocall_args_t* pargs_out = (oe_syscall_send_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->buf)
        OE_SET_IN_POINTER(buf, pargs_in->len, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_send_ocall(
        pargs_in->sockfd,
        (const void*)pargs_in->buf,
        pargs_in->len,
        pargs_in->flags);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_sendto_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_sendto_ocall_args_t* pargs_in = (oe_syscall_sendto_ocall_args_t*)input_buffer;
    oe_syscall_sendto_ocall_args_t* pargs_out = (oe_syscall_sendto_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->buf)
        OE_SET_IN_POINTER(buf, pargs_in->len, void*);
    if (pargs_in->dest_addr)
        OE_SET_IN_POINTER(dest_addr, pargs_in->addrlen, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_sendto_ocall(
        pargs_in->sockfd,
        (const void*)pargs_in->buf,
        pargs_in->len,
        pargs_in->flags,
        (const struct oe_sockaddr*)pargs_in->dest_addr,
        pargs_in->addrlen);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_recvv_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_recvv_ocall_args_t* pargs_in = (oe_syscall_recvv_ocall_args_t*)input_buffer;
    oe_syscall_recvv_ocall_args_t* pargs_out = (oe_syscall_recvv_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->iov_buf)
        OE_SET_IN_OUT_POINTER(iov_buf, pargs_in->iov_buf_size, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->iov_buf)
        OE_COPY_AND_SET_IN_OUT_POINTER(iov_buf, pargs_in->iov_buf_size, void*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_recvv_ocall(
        pargs_in->fd,
        pargs_in->iov_buf,
        pargs_in->iovcnt,
        pargs_in->iov_buf_size);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_sendv_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_sendv_ocall_args_t* pargs_in = (oe_syscall_sendv_ocall_args_t*)input_buffer;
    oe_syscall_sendv_ocall_args_t* pargs_out = (oe_syscall_sendv_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->iov_buf)
        OE_SET_IN_POINTER(iov_buf, pargs_in->iov_buf_size, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_sendv_ocall(
        pargs_in->fd,
        (const void*)pargs_in->iov_buf,
        pargs_in->iovcnt,
        pargs_in->iov_buf_size);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_shutdown_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_shutdown_ocall_args_t* pargs_in = (oe_syscall_shutdown_ocall_args_t*)input_buffer;
    oe_syscall_shutdown_ocall_args_t* pargs_out = (oe_syscall_shutdown_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_shutdown_ocall(
        pargs_in->sockfd,
        pargs_in->how);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_setsockopt_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_setsockopt_ocall_args_t* pargs_in = (oe_syscall_setsockopt_ocall_args_t*)input_buffer;
    oe_syscall_setsockopt_ocall_args_t* pargs_out = (oe_syscall_setsockopt_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->optval)
        OE_SET_IN_POINTER(optval, pargs_in->optlen, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_setsockopt_ocall(
        pargs_in->sockfd,
        pargs_in->level,
        pargs_in->optname,
        (const void*)pargs_in->optval,
        pargs_in->optlen);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getsockopt_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getsockopt_ocall_args_t* pargs_in = (oe_syscall_getsockopt_ocall_args_t*)input_buffer;
    oe_syscall_getsockopt_ocall_args_t* pargs_out = (oe_syscall_getsockopt_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->optval)
        OE_SET_OUT_POINTER(optval, pargs_in->optlen_in, void*);
    if (pargs_in->optlen_out)
        OE_SET_OUT_POINTER(optlen_out, sizeof(oe_socklen_t), oe_socklen_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getsockopt_ocall(
        pargs_in->sockfd,
        pargs_in->level,
        pargs_in->optname,
        pargs_in->optval,
        pargs_in->optlen_in,
        pargs_in->optlen_out);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getsockname_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getsockname_ocall_args_t* pargs_in = (oe_syscall_getsockname_ocall_args_t*)input_buffer;
    oe_syscall_getsockname_ocall_args_t* pargs_out = (oe_syscall_getsockname_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->addr)
        OE_SET_IN_OUT_POINTER(addr, pargs_in->addrlen_in, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->addr)
        OE_COPY_AND_SET_IN_OUT_POINTER(addr, pargs_in->addrlen_in, struct oe_sockaddr*);
    if (pargs_in->addrlen_out)
        OE_SET_OUT_POINTER(addrlen_out, 1, oe_socklen_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getsockname_ocall(
        pargs_in->sockfd,
        pargs_in->addr,
        pargs_in->addrlen_in,
        pargs_in->addrlen_out);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getpeername_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getpeername_ocall_args_t* pargs_in = (oe_syscall_getpeername_ocall_args_t*)input_buffer;
    oe_syscall_getpeername_ocall_args_t* pargs_out = (oe_syscall_getpeername_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->addr)
        OE_SET_IN_OUT_POINTER(addr, pargs_in->addrlen_in, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->addr)
        OE_COPY_AND_SET_IN_OUT_POINTER(addr, pargs_in->addrlen_in, struct oe_sockaddr*);
    if (pargs_in->addrlen_out)
        OE_SET_OUT_POINTER(addrlen_out, 1, oe_socklen_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getpeername_ocall(
        pargs_in->sockfd,
        pargs_in->addr,
        pargs_in->addrlen_in,
        pargs_in->addrlen_out);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getaddrinfo_open_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getaddrinfo_open_ocall_args_t* pargs_in = (oe_syscall_getaddrinfo_open_ocall_args_t*)input_buffer;
    oe_syscall_getaddrinfo_open_ocall_args_t* pargs_out = (oe_syscall_getaddrinfo_open_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->node)
        OE_SET_IN_POINTER(node, pargs_in->node_len * sizeof(char), char*);
    if (pargs_in->service)
        OE_SET_IN_POINTER(service, pargs_in->service_len * sizeof(char), char*);
    if (pargs_in->hints)
        OE_SET_IN_POINTER(hints, ((size_t)1 * sizeof(struct oe_addrinfo)), struct oe_addrinfo*);
    if (pargs_in->hints && pargs_in->hints->ai_addr)
        OE_SET_IN_POINTER(hints->ai_addr, pargs_in->hints->ai_addrlen, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->handle)
        OE_SET_OUT_POINTER(handle, ((size_t)1 * sizeof(uint64_t)), uint64_t*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getaddrinfo_open_ocall(
        (const char*)pargs_in->node,
        (const char*)pargs_in->service,
        (const struct oe_addrinfo*)pargs_in->hints,
        pargs_in->handle);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getaddrinfo_read_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getaddrinfo_read_ocall_args_t* pargs_in = (oe_syscall_getaddrinfo_read_ocall_args_t*)input_buffer;
    oe_syscall_getaddrinfo_read_ocall_args_t* pargs_out = (oe_syscall_getaddrinfo_read_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->ai_flags)
        OE_SET_OUT_POINTER(ai_flags, ((size_t)1 * sizeof(int)), int*);
    if (pargs_in->ai_family)
        OE_SET_OUT_POINTER(ai_family, ((size_t)1 * sizeof(int)), int*);
    if (pargs_in->ai_socktype)
        OE_SET_OUT_POINTER(ai_socktype, ((size_t)1 * sizeof(int)), int*);
    if (pargs_in->ai_protocol)
        OE_SET_OUT_POINTER(ai_protocol, ((size_t)1 * sizeof(int)), int*);
    if (pargs_in->ai_addrlen)
        OE_SET_OUT_POINTER(ai_addrlen, ((size_t)1 * sizeof(oe_socklen_t)), oe_socklen_t*);
    if (pargs_in->ai_addr)
        OE_SET_OUT_POINTER(ai_addr, pargs_in->ai_addrlen_in, struct oe_sockaddr*);
    if (pargs_in->ai_canonnamelen)
        OE_SET_OUT_POINTER(ai_canonnamelen, ((size_t)1 * sizeof(size_t)), size_t*);
    if (pargs_in->ai_canonname)
        OE_SET_OUT_POINTER(ai_canonname, pargs_in->ai_canonnamelen_in, char*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getaddrinfo_read_ocall(
        pargs_in->handle,
        pargs_in->ai_flags,
        pargs_in->ai_family,
        pargs_in->ai_socktype,
        pargs_in->ai_protocol,
        pargs_in->ai_addrlen_in,
        pargs_in->ai_addrlen,
        pargs_in->ai_addr,
        pargs_in->ai_canonnamelen_in,
        pargs_in->ai_canonnamelen,
        pargs_in->ai_canonname);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getaddrinfo_close_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getaddrinfo_close_ocall_args_t* pargs_in = (oe_syscall_getaddrinfo_close_ocall_args_t*)input_buffer;
    oe_syscall_getaddrinfo_close_ocall_args_t* pargs_out = (oe_syscall_getaddrinfo_close_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getaddrinfo_close_ocall(
        pargs_in->handle);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getnameinfo_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getnameinfo_ocall_args_t* pargs_in = (oe_syscall_getnameinfo_ocall_args_t*)input_buffer;
    oe_syscall_getnameinfo_ocall_args_t* pargs_out = (oe_syscall_getnameinfo_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->sa)
        OE_SET_IN_POINTER(sa, pargs_in->salen, struct oe_sockaddr*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->host)
        OE_SET_OUT_POINTER(host, pargs_in->hostlen, char*);
    if (pargs_in->serv)
        OE_SET_OUT_POINTER(serv, pargs_in->servlen, char*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getnameinfo_ocall(
        (const struct oe_sockaddr*)pargs_in->sa,
        pargs_in->salen,
        pargs_in->host,
        pargs_in->hostlen,
        pargs_in->serv,
        pargs_in->servlen,
        pargs_in->flags);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_nanosleep_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_nanosleep_ocall_args_t* pargs_in = (oe_syscall_nanosleep_ocall_args_t*)input_buffer;
    oe_syscall_nanosleep_ocall_args_t* pargs_out = (oe_syscall_nanosleep_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->req)
        OE_SET_IN_POINTER(req, sizeof(struct oe_timespec), struct oe_timespec*);
    if (pargs_in->rem)
        OE_SET_IN_OUT_POINTER(rem, sizeof(struct oe_timespec), struct oe_timespec*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->rem)
        OE_COPY_AND_SET_IN_OUT_POINTER(rem, sizeof(struct oe_timespec), struct oe_timespec*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_nanosleep_ocall(
        pargs_in->req,
        pargs_in->rem);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getpid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getpid_ocall_args_t* pargs_in = (oe_syscall_getpid_ocall_args_t*)input_buffer;
    oe_syscall_getpid_ocall_args_t* pargs_out = (oe_syscall_getpid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getpid_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getppid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getppid_ocall_args_t* pargs_in = (oe_syscall_getppid_ocall_args_t*)input_buffer;
    oe_syscall_getppid_ocall_args_t* pargs_out = (oe_syscall_getppid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getppid_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getpgrp_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getpgrp_ocall_args_t* pargs_in = (oe_syscall_getpgrp_ocall_args_t*)input_buffer;
    oe_syscall_getpgrp_ocall_args_t* pargs_out = (oe_syscall_getpgrp_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getpgrp_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getuid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getuid_ocall_args_t* pargs_in = (oe_syscall_getuid_ocall_args_t*)input_buffer;
    oe_syscall_getuid_ocall_args_t* pargs_out = (oe_syscall_getuid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getuid_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_geteuid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_geteuid_ocall_args_t* pargs_in = (oe_syscall_geteuid_ocall_args_t*)input_buffer;
    oe_syscall_geteuid_ocall_args_t* pargs_out = (oe_syscall_geteuid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_geteuid_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getgid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getgid_ocall_args_t* pargs_in = (oe_syscall_getgid_ocall_args_t*)input_buffer;
    oe_syscall_getgid_ocall_args_t* pargs_out = (oe_syscall_getgid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getgid_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getegid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getegid_ocall_args_t* pargs_in = (oe_syscall_getegid_ocall_args_t*)input_buffer;
    oe_syscall_getegid_ocall_args_t* pargs_out = (oe_syscall_getegid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getegid_ocall(
    );

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getpgid_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getpgid_ocall_args_t* pargs_in = (oe_syscall_getpgid_ocall_args_t*)input_buffer;
    oe_syscall_getpgid_ocall_args_t* pargs_out = (oe_syscall_getpgid_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getpgid_ocall(
        pargs_in->pid);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_getgroups_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_getgroups_ocall_args_t* pargs_in = (oe_syscall_getgroups_ocall_args_t*)input_buffer;
    oe_syscall_getgroups_ocall_args_t* pargs_out = (oe_syscall_getgroups_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->list)
        OE_SET_OUT_POINTER(list, ((size_t)pargs_in->size * sizeof(unsigned int)), unsigned int*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_getgroups_ocall(
        pargs_in->size,
        pargs_in->list);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_syscall_uname_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_syscall_uname_ocall_args_t* pargs_in = (oe_syscall_uname_ocall_args_t*)input_buffer;
    oe_syscall_uname_ocall_args_t* pargs_out = (oe_syscall_uname_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->buf)
        OE_SET_OUT_POINTER(buf, ((size_t)1 * sizeof(struct oe_utsname)), struct oe_utsname*);

    /* Call user function. */
    pargs_out->_retval = oe_syscall_uname_ocall(
        pargs_in->buf);

    /* Propagate errno back to enclave. */
    pargs_out->_ocall_errno = errno;

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_get_supported_attester_format_ids_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_get_supported_attester_format_ids_ocall_args_t* pargs_in = (oe_get_supported_attester_format_ids_ocall_args_t*)input_buffer;
    oe_get_supported_attester_format_ids_ocall_args_t* pargs_out = (oe_get_supported_attester_format_ids_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->format_ids)
        OE_SET_OUT_POINTER(format_ids, pargs_in->format_ids_size, void*);
    if (pargs_in->format_ids_size_out)
        OE_SET_OUT_POINTER(format_ids_size_out, sizeof(size_t), size_t*);

    /* Call user function. */
    pargs_out->_retval = oe_get_supported_attester_format_ids_ocall(
        pargs_in->format_ids,
        pargs_in->format_ids_size,
        pargs_in->format_ids_size_out);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_get_qetarget_info_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_get_qetarget_info_ocall_args_t* pargs_in = (oe_get_qetarget_info_ocall_args_t*)input_buffer;
    oe_get_qetarget_info_ocall_args_t* pargs_out = (oe_get_qetarget_info_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->format_id)
        OE_SET_IN_POINTER(format_id, sizeof(oe_uuid_t), oe_uuid_t*);
    if (pargs_in->opt_params)
        OE_SET_IN_POINTER(opt_params, pargs_in->opt_params_size, void*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->target_info)
        OE_SET_OUT_POINTER(target_info, sizeof(sgx_target_info_t), sgx_target_info_t*);

    /* Call user function. */
    pargs_out->_retval = oe_get_qetarget_info_ocall(
        (const oe_uuid_t*)pargs_in->format_id,
        (const void*)pargs_in->opt_params,
        pargs_in->opt_params_size,
        pargs_in->target_info);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_get_quote_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_get_quote_ocall_args_t* pargs_in = (oe_get_quote_ocall_args_t*)input_buffer;
    oe_get_quote_ocall_args_t* pargs_out = (oe_get_quote_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->format_id)
        OE_SET_IN_POINTER(format_id, sizeof(oe_uuid_t), oe_uuid_t*);
    if (pargs_in->opt_params)
        OE_SET_IN_POINTER(opt_params, pargs_in->opt_params_size, void*);
    if (pargs_in->sgx_report)
        OE_SET_IN_POINTER(sgx_report, sizeof(sgx_report_t), sgx_report_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->quote)
        OE_SET_OUT_POINTER(quote, pargs_in->quote_size, void*);
    if (pargs_in->quote_size_out)
        OE_SET_OUT_POINTER(quote_size_out, sizeof(size_t), size_t*);

    /* Call user function. */
    pargs_out->_retval = oe_get_quote_ocall(
        (const oe_uuid_t*)pargs_in->format_id,
        (const void*)pargs_in->opt_params,
        pargs_in->opt_params_size,
        (const sgx_report_t*)pargs_in->sgx_report,
        pargs_in->quote,
        pargs_in->quote_size,
        pargs_in->quote_size_out);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_get_quote_verification_collateral_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_get_quote_verification_collateral_ocall_args_t* pargs_in = (oe_get_quote_verification_collateral_ocall_args_t*)input_buffer;
    oe_get_quote_verification_collateral_ocall_args_t* pargs_out = (oe_get_quote_verification_collateral_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->fmspc)
        OE_SET_IN_POINTER(fmspc, sizeof(uint8_t[6]), uint8_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->tcb_info)
        OE_SET_OUT_POINTER(tcb_info, pargs_in->tcb_info_size, void*);
    if (pargs_in->tcb_info_size_out)
        OE_SET_OUT_POINTER(tcb_info_size_out, sizeof(size_t), size_t*);
    if (pargs_in->tcb_info_issuer_chain)
        OE_SET_OUT_POINTER(tcb_info_issuer_chain, pargs_in->tcb_info_issuer_chain_size, void*);
    if (pargs_in->tcb_info_issuer_chain_size_out)
        OE_SET_OUT_POINTER(tcb_info_issuer_chain_size_out, sizeof(size_t), size_t*);
    if (pargs_in->pck_crl)
        OE_SET_OUT_POINTER(pck_crl, pargs_in->pck_crl_size, void*);
    if (pargs_in->pck_crl_size_out)
        OE_SET_OUT_POINTER(pck_crl_size_out, sizeof(size_t), size_t*);
    if (pargs_in->root_ca_crl)
        OE_SET_OUT_POINTER(root_ca_crl, pargs_in->root_ca_crl_size, void*);
    if (pargs_in->root_ca_crl_size_out)
        OE_SET_OUT_POINTER(root_ca_crl_size_out, sizeof(size_t), size_t*);
    if (pargs_in->pck_crl_issuer_chain)
        OE_SET_OUT_POINTER(pck_crl_issuer_chain, pargs_in->pck_crl_issuer_chain_size, void*);
    if (pargs_in->pck_crl_issuer_chain_size_out)
        OE_SET_OUT_POINTER(pck_crl_issuer_chain_size_out, sizeof(size_t), size_t*);
    if (pargs_in->qe_identity)
        OE_SET_OUT_POINTER(qe_identity, pargs_in->qe_identity_size, void*);
    if (pargs_in->qe_identity_size_out)
        OE_SET_OUT_POINTER(qe_identity_size_out, sizeof(size_t), size_t*);
    if (pargs_in->qe_identity_issuer_chain)
        OE_SET_OUT_POINTER(qe_identity_issuer_chain, pargs_in->qe_identity_issuer_chain_size, void*);
    if (pargs_in->qe_identity_issuer_chain_size_out)
        OE_SET_OUT_POINTER(qe_identity_issuer_chain_size_out, sizeof(size_t), size_t*);

    /* Call user function. */
    pargs_out->_retval = oe_get_quote_verification_collateral_ocall(
        *(uint8_t(*)[6])pargs_in->fmspc,
        pargs_in->tcb_info,
        pargs_in->tcb_info_size,
        pargs_in->tcb_info_size_out,
        pargs_in->tcb_info_issuer_chain,
        pargs_in->tcb_info_issuer_chain_size,
        pargs_in->tcb_info_issuer_chain_size_out,
        pargs_in->pck_crl,
        pargs_in->pck_crl_size,
        pargs_in->pck_crl_size_out,
        pargs_in->root_ca_crl,
        pargs_in->root_ca_crl_size,
        pargs_in->root_ca_crl_size_out,
        pargs_in->pck_crl_issuer_chain,
        pargs_in->pck_crl_issuer_chain_size,
        pargs_in->pck_crl_issuer_chain_size_out,
        pargs_in->qe_identity,
        pargs_in->qe_identity_size,
        pargs_in->qe_identity_size_out,
        pargs_in->qe_identity_issuer_chain,
        pargs_in->qe_identity_issuer_chain_size,
        pargs_in->qe_identity_issuer_chain_size_out);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_sgx_get_cpuid_table_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_sgx_get_cpuid_table_ocall_args_t* pargs_in = (oe_sgx_get_cpuid_table_ocall_args_t*)input_buffer;
    oe_sgx_get_cpuid_table_ocall_args_t* pargs_out = (oe_sgx_get_cpuid_table_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->cpuid_table_buffer)
        OE_SET_OUT_POINTER(cpuid_table_buffer, pargs_in->cpuid_table_buffer_size, void*);

    /* Call user function. */
    pargs_out->_retval = oe_sgx_get_cpuid_table_ocall(
        pargs_in->cpuid_table_buffer,
        pargs_in->cpuid_table_buffer_size);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_sgx_backtrace_symbols_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_sgx_backtrace_symbols_ocall_args_t* pargs_in = (oe_sgx_backtrace_symbols_ocall_args_t*)input_buffer;
    oe_sgx_backtrace_symbols_ocall_args_t* pargs_out = (oe_sgx_backtrace_symbols_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->buffer)
        OE_SET_IN_POINTER(buffer, ((size_t)pargs_in->size * sizeof(uint64_t)), uint64_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->symbols_buffer)
        OE_SET_OUT_POINTER(symbols_buffer, pargs_in->symbols_buffer_size, void*);
    if (pargs_in->symbols_buffer_size_out)
        OE_SET_OUT_POINTER(symbols_buffer_size_out, sizeof(size_t), size_t*);

    /* Call user function. */
    pargs_out->_retval = oe_sgx_backtrace_symbols_ocall(
        pargs_in->oe_enclave,
        (const uint64_t*)pargs_in->buffer,
        pargs_in->size,
        pargs_in->symbols_buffer,
        pargs_in->symbols_buffer_size,
        pargs_in->symbols_buffer_size_out);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_sgx_thread_wake_wait_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_sgx_thread_wake_wait_ocall_args_t* pargs_in = (oe_sgx_thread_wake_wait_ocall_args_t*)input_buffer;
    oe_sgx_thread_wake_wait_ocall_args_t* pargs_out = (oe_sgx_thread_wake_wait_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    oe_sgx_thread_wake_wait_ocall(
        pargs_in->oe_enclave,
        pargs_in->waiter_tcs,
        pargs_in->self_tcs);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_sgx_wake_switchless_worker_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_sgx_wake_switchless_worker_ocall_args_t* pargs_in = (oe_sgx_wake_switchless_worker_ocall_args_t*)input_buffer;
    oe_sgx_wake_switchless_worker_ocall_args_t* pargs_out = (oe_sgx_wake_switchless_worker_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    oe_sgx_wake_switchless_worker_ocall(
        pargs_in->context);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_sgx_sleep_switchless_worker_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_sgx_sleep_switchless_worker_ocall_args_t* pargs_in = (oe_sgx_sleep_switchless_worker_ocall_args_t*)input_buffer;
    oe_sgx_sleep_switchless_worker_ocall_args_t* pargs_out = (oe_sgx_sleep_switchless_worker_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    /* There were no out nor in-out parameters. */

    /* Call user function. */
    oe_sgx_sleep_switchless_worker_ocall(
        pargs_in->context);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

/**** OCALL function table. ****/

static oe_ocall_func_t __localattestation_ocall_function_table[] = {
    (oe_ocall_func_t) ocall_oe_log_ocall,
    (oe_ocall_func_t) ocall_oe_write_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_epoll_create1_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_epoll_wait_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_epoll_wake_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_epoll_ctl_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_epoll_close_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_open_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_read_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_write_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_readv_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_writev_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_lseek_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_pread_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_pwrite_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_close_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_dup_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_opendir_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_readdir_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_rewinddir_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_closedir_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_stat_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_access_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_link_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_unlink_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_rename_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_truncate_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_mkdir_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_rmdir_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_fcntl_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_ioctl_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_poll_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_kill_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_close_socket_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_socket_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_shutdown_sockets_device_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_socketpair_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_connect_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_accept_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_bind_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_listen_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_recvmsg_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_sendmsg_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_recv_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_recvfrom_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_send_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_sendto_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_recvv_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_sendv_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_shutdown_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_setsockopt_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getsockopt_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getsockname_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getpeername_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getaddrinfo_open_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getaddrinfo_read_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getaddrinfo_close_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getnameinfo_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_nanosleep_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getpid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getppid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getpgrp_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getuid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_geteuid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getgid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getegid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getpgid_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_getgroups_ocall,
    (oe_ocall_func_t) ocall_oe_syscall_uname_ocall,
    (oe_ocall_func_t) ocall_oe_get_supported_attester_format_ids_ocall,
    (oe_ocall_func_t) ocall_oe_get_qetarget_info_ocall,
    (oe_ocall_func_t) ocall_oe_get_quote_ocall,
    (oe_ocall_func_t) ocall_oe_get_quote_verification_collateral_ocall,
    (oe_ocall_func_t) ocall_oe_sgx_get_cpuid_table_ocall,
    (oe_ocall_func_t) ocall_oe_sgx_backtrace_symbols_ocall,
    (oe_ocall_func_t) ocall_oe_sgx_thread_wake_wait_ocall,
    (oe_ocall_func_t) ocall_oe_sgx_wake_switchless_worker_ocall,
    (oe_ocall_func_t) ocall_oe_sgx_sleep_switchless_worker_ocall,
    NULL
};

oe_result_t oe_create_localattestation_enclave(
    const char* path,
    oe_enclave_type_t type,
    uint32_t flags,
    const oe_enclave_setting_t* settings,
    uint32_t setting_count,
    oe_enclave_t** enclave)
{
    return oe_create_enclave(
               path,
               type,
               flags,
               settings,
               setting_count,
               __localattestation_ocall_function_table,
               78,
               enclave);
}

OE_EXTERNC_END
